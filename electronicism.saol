global{	srate 44100;	krate 1000;	outchannels 2;	route(bus1, delaytest);	route(bus2, filterb);	route(bus3, hihat);	route(bus4, pad);		route(bus5, arpsound2);	send(filterb; ; bus1);	send(mystdelay; ;bus2, bus4, bus5);	send(mystdelay2; ;bus3);}instr delaytest(pitch, vel) preset 0{	ksig coef[5];	asig in, out, first, temp, sound;	ksig env;	oparray fracdelay[1];	env = kline (0, 0.001, 1, 0.001, 0, 0.001, 1, 0.001, 0);	in = arand(0.5) * env;	if(!first)		{		first = 1;		fracdelay[0](1, 1/cpsmidi(pitch));	// initialiseren van de 		}	coef = butter_gainlp(coef, MIDIctrl[1] * 100);		out = fracdelay[0](5);	temp = butterw(out, coef);	fracdelay[0](3,0,in + -1 * temp); 		sound = in + out;	if(MIDIctrl[91] >= 1)	{	sound = pow(sin(sound*3.14), 4);	}		output (sound * 0.5);}instr bassdrum(pitch, vel) preset 1{	ksig env;	asig env2;	asig sound;	table sine(harm, 16384, 1);			env2 = aline(0, 0.001, 1, 0.36, 0);	env = kline(10, 0.001, 440, 0.01, 51, 0.3, 51);	sound = oscil(sine, env);		output (sound * env2 * 0.125);}instr hihat(pitch, vel) preset 2{	ksig env;	asig env2;	asig sound;	table sine(harm, 16384, 1);			env2 = aline(0, 0.001, 1, 0.01, 0);	env = kline(10, 0.001, 15000, 0.01, 10);	sound = oscil(sine, env);		output (sound * env2 * 0.0225);}instr pad(pitch, vel) preset 3 {        ivar attack,release, attlim, ktime, stime;        ksig incr, rel, tot;        ksig modlfo;        ksig amplfo;        ksig lfo;        ivar freq;        ksig cf;        ksig coef[5];        asig noise, env;        table osc(buzz, 2048, -1, 0, 0.9);                freq = cpsmidi(pitch);        modlfo  = lfo(1, 4, 2, 0);        amplfo  = lfo(4 + modlfo, 1, 0, 0);                ktime = 1/k_rate;        stime = 1/s_rate;        attack = int(0.5/ktime)*ktime;        release = int(0.5/ktime)*ktime;        attlim = attack - 0.5*ktime;        incr = 0;        if (released && !rel)        {        rel = 1;        extend(release);        }        if ((!rel) && (itime < attlim))        {        incr = stime/attack;        tot = tot + ktime/attack;        }        if (rel)        {        incr = -tot*stime/(release+2*ktime);        }        noise = oscil(osc, freq) * amplfo;                lfo = lfo(4, 2, 2, 0) - 1;        cf = port(MIDIctrl[1], 0.01);        coef = butter_gainbp(coef, lfo * 450 + 250, 30);        noise = butterw(noise, coef);                   env = env + incr;        output (noise * 0.8 * env);}instr arpsound2(pitch, vel) preset 4{               ivar attack,release, attlim, ktime, stime;        ksig incr, rel, tot;        ksig coef[5];        ksig cf;        asig sound, env;        table osc(buzz, 2048, -1, 0, 0.3);                                ktime = 1/k_rate;        stime = 1/s_rate;        attack = int(0.01/ktime)*ktime;        release = int(0.01/ktime)*ktime;        attlim = attack - 0.5*ktime;        incr = 0;        if (released && !rel)        {        rel = 1;        extend(release);        }        if ((!rel) && (itime < attlim))        {        incr = stime/attack;        tot = tot + ktime/attack;        }        if (rel)        {        incr = -tot*stime/(release+2*ktime);        }        sound = oscil(osc, cpsmidi(pitch));        coef = butter_gainlp(coef, 80 + vel * 5);        sound = butterw(sound, coef);        sound = pow(sin(3.14 * sound), 4);        env =env + incr;        sound = flange(sound, 3, 70);        output (sound * 0.1 * env);}instr filterb(){	ksig lfo,lfo2, coef[5];	asig out;	table sine(harm, 512, 1);	lfo = koscil(sine, 2);			lfo2 = koscil(sine, 3);	coef = butter_gainbp(coef, 400 + (lfo * 370), 60 + (50 * (lfo2 + 1)));	out = butterw(input[0], coef);		output(out);}instr mystdelay(){	output (0.5 * input[0] + 0.5 * stereodelay(input[0]+input[1]+input[2], 0.3, 0.4, 0.3, 0.3));}instr mystdelay2(){	output (0.5 * input[0] + 0.5 * stereodelay(input[0], 0.01, 0.01, 0.8, 0.8));}//------Butterworth filters--------------------------------------------------------------------------------------------------aopcode butterw(asig sound_in, ksig gains[5]){       //      recursive filter structure, programmed by Peter Maas (www.saol.net)//      recursive filter structure, entered gains (suplied in following opcodes) set the parameters.        asig XBuffer[3];        asig YBuffer[3];        asig sound_out;                                XBuffer[2]=XBuffer[1];                 XBuffer[1]=XBuffer[0];                 XBuffer[0]=sound_in;                      YBuffer[0] = (gains[0]*XBuffer[0] + gains[1]*XBuffer[1] + gains[2]*XBuffer[2] - gains[3]*YBuffer[1] - gains[4]*YBuffer[2]);                          YBuffer[2]=YBuffer[1];                 YBuffer[1]=YBuffer[0];                 sound_out=YBuffer[0];         return(sound_out);}//------One of the Opcodes to generate gains for the butterw aopcode----------------------------------------------------------//------This one generates the gains for a low pass filter--------------------------------------------------------------------kopcode butter_gainlp(ksig coef[5], ksig fc){//      Calculate gains for a butterworth lowpass filter, first input is the signal thats going to hold the coefficients.//      second input is the cutoff frequency of the filter//      Programmed by Peter Maas (www.saol.net)        ksig c;         c = pow((sin(3.14159 * (fc + 1) / s_rate) / (cos(3.14159 * (fc + 1) / s_rate))), -1);         coef[0] = 1/(1 + sqrt(2*c) + c*c);        coef[1] = 2 * coef[0];         coef[2] = coef[0];         coef[3] = 2 * (1 - c*c) * coef[0];         coef[4] = (1 - sqrt(2*c) + c*c) * coef[0];        return (coef);}kopcode butter_gainbp(ksig coef[5], ksig fc, ksig bw){//      Calculate gains for a butterworth lowpass filter, first input is the signal thats going to hold the coefficients.//      second input is the cutoff frequency of the filter, third input is the bandwith//      Programmed by Peter Maas (www.saol.net)        ksig c;         ksig d;        c = pow((sin(3.14159 * (bw + 1) / s_rate) / cos(3.14159 * (bw + 1) / s_rate)), -1);         d = 2 * cos(2*3.14159 * fc / s_rate);        coef[0] = 1/(1 + c);        coef[1] = 0;         coef[2] = -1 * coef[0];         coef[3] = -1 * c * d * coef[0];         coef[4] = (c - 1) * coef[0];        return (coef);}//---------------------------------------------------------------------------------------------------------------------------//------Stereo Delay---------------------------------------------------------------------------------------------------------aopcode stereodelay(asig delay_input, ivar dtimeL, ivar dtimeR, ksig fbL, ksig fbR){        // dtimeL and dtimeR are the delaytimes for left and right channel        //        // fbL and fbR are the feedbackfactors        // feedbackfactor = 0               -> no feedback        // feedbackfactor = between 0 and 1 -> volume of the delay decreases        // feedbackfactor = 1               -> constant volume        // feedbackfactor = higher than 1   -> volume of the delay increases        // (negative values invert the signal)        //        // written by Peter van der Noord	// www.saol.net                asig L, R, feedbackL, feedbackR;                L               = delay_input + feedbackL;        feedbackL       = fbL * delay (L, dtimeL);                R               = delay_input + feedbackR;        feedbackR       = fbR * delay (R, dtimeR);                        return (L, R);}//---------------------------------------------------------------------------------------------------------------------------//------Lfo------------------------------------------------------------------------------------------------------------------kopcode lfo(ksig freq, ksig amp, ksig shape, ksig smooth)	{//	LFO module programmed by Peter Maas (www.saol.net)//	freq	=	lfo speed//	amp	=	lfo amplitude//	shape	=	waveform (0 = square, 1 = saw, 2 = sine)//	smooth	=	smooths the lfo wave//------Declaration of variables---------------------------------------------------	ksig lfo;//------tables used for lfo waveforms---------------------------------------------- //------0 = square || 1 = saw || 3 = sine ----------------------------------------- 	table square(step, 2, 0, 1, 1);	table sine(window, 2048, 2);//---------------------------------------------------------------------------------//------If statements for different waveforms, changable at krate------------------	if(shape == 0)	// square	{		lfo = koscil(square, freq);	}	if(shape == 1)	// saw	{		lfo = kphasor(freq);	}			if(shape == 2)	// sine	{		lfo = koscil(sine, freq);		lfo = ((lfo + 1) / 2);	}	//----------------------------------------------------------------------------------//------Amplification factor for LFO range------------------------------------------	lfo = lfo * amp;//----------------------------------------------------------------------------------//------Smoothing lfo signal--------------------------------------------------------	if(smooth >= 1)	{		lfo = port(lfo, 0.05);	}	return(lfo);}